# Copyright (c) 2018, 2019 MariaDB Corporation Ab.
# Use is subject to license terms.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
# USA
#

package Simplifier;

# Note about history and future of this script
# --------------------------------------------
# The concept and code here is only in some portions based on
#    util/simplify-grammar.pl
# There we have GNU General Public License version 2 too and
# Copyright (c) 2008, 2011 Oracle and/or its affiliates. All rights reserved.
# Copyright (c) 2013, Monty Program Ab.
# Copyright (c) 2018, MariaDB Corporation Ab.
#
# The amount of parameters (call line + config file) is in the moment
# not that stable.
# On the long run the script rql_batch.pl will be extended and replace
# the current script.
#

use strict;
use warnings;
use lib 'lib';
use lib '../lib';
use DBI;
use Carp;
use Getopt::Long;
use Data::Dumper;

use GenTest;
use GenTest::Constants;
use GenTest::Grammar;
use Batch;
use Auxiliary;
use Verdict;
use GenTest::Properties;
use GenTest::Simplifier::Grammar_advanced; # We use the correct working simplifier only.
use Time::HiRes;

my $phase        = '';
my $phase_switch = 0;
# (Most probably) needed because of technical reasons.
use constant PHASE_SIMP_BEGIN       => 'simp_begin';
#
# Attempt to replay with the compactified initial grammar.
use constant PHASE_FIRST_REPLAY     => 'first_replay';
#
# Attempt to replay with the actual best replaying grammar and threads = 1,
use constant PHASE_THREAD1_REPLAY   => 'thread1_replay';
#
# Attempt to shrink the amount of reporters, validators, transformers.
use constant PHASE_RVT_SIMP         => 'rvt_simp';
#
# Attempt to shrink the actual best replaying grammar
# - with avoiding to destroy rules because that could change the semantics of the test.
#   == Never try to replace the last component of a rule by an empty string.
#   Compared to the alternative PHASE_GRAMMAR_DEST
#   - Advantage
#     No risk to change the semantics of the test and than maybe harvesting false positives.
#   - Disadvantage
#     In case of bad effects where this risk does not exist, a typical example are asserts
#     caused by concurrent activitity, some maybe a bot slower simplification speed.
use constant PHASE_GRAMMAR_SIMP     => 'grammar_simp';
# - without avoiding to destroy rules.
#   == Trying to replace the last component of a rule by an empty string is allowed like in
#      the old simplification mechanism. We take the risk to maybe change the semantics of the test.
#   PHASE_GRAMMAR_DEST optimizes this by trying
#   1. <rule>: ;   # Even top level rules will get attacked.
#   2. - n. Just the simplification attempts generated by PHASE_GRAMMAR_SIMP.
use constant PHASE_GRAMMAR_DEST     => 'grammar_dest';
#
# Attempt to clone rules
# - containing more than one alternative/component
# - being used more than once
# within the actual best replaying grammar.
# In case this is not a no op than there must a PHASE_GRAMMAR_SIMP round follow.
use constant PHASE_GRAMMAR_CLONE    => 'grammar_clone';    # Implementation later
#
# Replace grammar language builtins like _digit and similar by rules doing the same.
# In case this is not a no op than there must a PHASE_GRAMMAR_SIMP round follow.
use constant PHASE_GRAMMAR_BUILTIN  => 'grammar_builtin';  # Implementation later if ever
#
# Attempt to replay with the actual best replaying grammar.
use constant PHASE_FINAL_REPLAY     => 'final_replay';
#
# (Most probably) needed because of technical reasons.
use constant PHASE_SIMP_END         => 'simp_end';

# This is the list of values which the user is allowed to set.
use constant PHASE_SIMP_ALLOWED_VALUE_LIST => [
      PHASE_FIRST_REPLAY, PHASE_THREAD1_REPLAY, PHASE_RVT_SIMP, PHASE_GRAMMAR_SIMP,
      PHASE_GRAMMAR_DEST, PHASE_GRAMMAR_CLONE, PHASE_GRAMMAR_BUILTIN, PHASE_FINAL_REPLAY,
   ];
# FIXME:
# PHASE_THREAD1_REPLAY, PHASE_RVT_SIMP are capable to cut the replay runtime+complexity of test
# serious down. But they could also suffer from a low likelihood to replay.
my @simp_chain_default = ( # PHASE_SIMP_BEGIN,
                           PHASE_FIRST_REPLAY,
                           PHASE_THREAD1_REPLAY,
                           PHASE_RVT_SIMP,
                           PHASE_GRAMMAR_SIMP,
                           PHASE_FINAL_REPLAY,
                           # PHASE_SIMP_END,
                         );

# Attack_mode     --- not to be set from outside
# with (most probably) impact on
# - generate_order
# - validate_order
# - process_result
# - get_job   (deliver cl_snip for rqg.pl)
#
# rqg_batch extracts workdir/vardir/build thread/bwlists
# Simplifier + combinator do not to know that except workdir if at all.
# Simplifier + combinator work with Batch.pm and rqg_batch does not!!

# Grammar simplification algorithms
# ---------------------------------
my $algorithm;
use constant SIMP_ALGO_WEIGHT     => 'weight';
use constant SIMP_ALGO_RANDOM     => 'random';  # not yet implemented
use constant SIMP_ALGO_MASKING    => 'masking'; # not yet implemented


# Structure for managing orders
# -----------------------------
# FIXME: Explain better
# The parent inits some routine and configures hereby what the goal of the current rqg_batch run is
# - "free" bug hunting by executing a crowd of jobs generated
#   - from combinations config file
#   - via to be implemented variations of parameters like (seed, mask, etc.)
# - fast replay of some well defined bug based on variations of parameters
#   The main difference to the free bughunting above is that the parent stops all other RQG Worker,
#   cleans up and exits as soon as a RQG worker had the verdict "replay".
# - grammar simplification
# There are two main reasons why some order management is required:
# 1. The fastest grammar simplification mechanism
#    - works with chunks of orders
#      rule_a has 4 components --> 4 different orders.
#      And its easier to add the complete chunk on the fly than to handle only one order.
#    - repeats frequent the execution of some order because
#      - the order might have not had success on the previous execution but it looks as if repeating
#        that execution is the most promising we could do
#      - the order had uccess on the previous execution but it was a second "winner", so its
#        simplification could be not applied. But trying again is highly recommended.
#    - tries to get a faster simplification via bookkeeping about efforts invested in orders.
# 2. Independent of the goal of the batch run the parent might be forced to stop some ongoing
#    RQG worker in order to avoid to run into trouble with resources (free space in vardir etc.).
#    In case of
#    - grammar simplification we would have stopped some of the in theory most promising
#      simplification candidates. The most promising regarding speed of progress are started first.
#    - "free" bughunting based on combinations we have now a coverage gap.
#      m - 1 (executed), m (stopped=not covered), m + 1 (executed), ...
#    So its recommended to execute that job again as soon as possible.
#    Note: Some sophisticated resource control is more than just preventing disasters at runtime.
#          It adusts the load dynamic to any hardware and setup of tests met.
#
my @order_array = ();
# index is the id of creation in generate_order
#
# ORDER_EFFORTS_INVESTED
# Number of RQG runs for that orderid or sum of their runtimes
use constant ORDER_EFFORTS_INVESTED  => 0;

# ORDER_PROPERTY1
# Snip of the command line for the RQG runner.
use constant ORDER_PROPERTY1         => 1;
#
# ORDER_PROPERTY2 , comb_counter
# Example: start_combination = 2 , trials = 3
# comb_counter | order_id
#            1 | not stored because < start_combination
#            2 |        1
#            3 |        2
#            4 |        3
#
use constant ORDER_PROPERTY2         => 2;
#
# ORDER_PROPERTY3 , unused
use constant ORDER_PROPERTY3         => 3;
#
# ORDER_EFFORTS_LEFT_OVER
# (Current) maximum number of allowed left over finished RQG runs with that order id.
# Create order --> ORDER_EFFORTS_LEFT_OVER = $trials
# A RQG run with that order was regular finished != stopped (treatment in following order)
# 1. It was a finished RQG run             --> decrement ORDER_EFFORTS_LEFT_OVER
# 2. In case the RQG run achieved a replay --> increment ORDER_EFFORTS_LEFT_OVER two times
# 3. In case the RQG run achieved no replay and ORDER_EFFORTS_LEFT_OVER <= 0
#    --> Stop all ongoing RQG runs using that order and
#        move the order id into %try_exhausted_hash + remove it from other hashes.
use constant ORDER_EFFORTS_LEFT_OVER => 4;

my $workdir;

my $config_file;
my $config_file_copy_rel = "simplifier.cfg";

# File for bookkeeping + easy overview about results achieved.
my $result_file;

# Constants serving for more convenient printing of results in table layout
# -------------------------------------------------------------------------
use constant RQG_DERIVATE_TITLE    => 'Derivate used     ';
use constant RQG_PARENT_TITLE      => 'Parent of derivate';
use constant RQG_SPECIALITY_LENGTH => 18;             # Maximum is Title
my $title_line_part =
       " | " . Batch::RQG_NO_TITLE        . " | " . Verdict::RQG_VERDICT_TITLE .
       " | " . Batch::RQG_LOG_TITLE       . " | " . Batch::RQG_ORDERID_TITLE   .
       " | " . "RunTime"                  . " | " . RQG_DERIVATE_TITLE         .
       " | " . RQG_PARENT_TITLE . "\n";

# Whatever trials
# ---------------
# Variable for assigning the maximum number of regular finished RQG runs (!= stopped)
# before giving up in case no replay was achieved.
# To be applied to certain phases like PHASE_*_REPLAY only.
my $trials;
# Default for maximum number of trials in these phases.
# Just to be used in case the user has not assigned a value via command line or config file.
use constant TRIALS_DEFAULT         => 30;
#
# Maximum number of left over to be regular finished trials.
# The value gets set when switching the phase.
my $left_over_trials;
#
# Maximum number of trials in the phase PHASE_GRAMMAR_SIMP/PHASE_GRAMMAR_DEST
#   The user cannot override that value via command line or config file.
#   Its just a high value for catching obvious "ill" simplification runs.
use constant TRIALS_SIMP            => 99999;

use constant QUERIES_DEFAULT        => 1000000;

# Parameters typical for Simplifier runs
# --------------------------------------
my $seed;

my $grammar_file;

my $threads;
use constant THREADS_DEFAULT        => 10;

# Name of the convenience symlink if symlinking supported by OS
my $symlink = "last_batch_workdir";

# Assembling of the RQG runner call via cl_snip (call line snips)
# ===============================================================
# 1. There is some first snip
#    - held by rqg_batch.pl and/or lib/Batch.pm
#    - containing settings extracted or computed from ARGV etc.
#      These settings serve for making some RQG run with arbitrary purpose like
#      - general bug hunting or replay of specific bug with Combinator/Variator
#      - grammar simplification
#      possible and free of clashes with concurrent RQG runs.
#    Example: --basedir... --vardir=... --mtr-build-thread=... etc.
#    This snip is not "known" to lib/Simplifier.pm.
# 2. The second snip which is mostly (*) valid(static) for all Simplification phases.
#    Example: "--gendata...." (But only as long as gendata is not target of a simplification phase.)
#    There are currently two reasons for handling this here:
#    1. Certain option settings are not known to rqg_batch.pl because they are contained
#       within the simplifier config file. And this file is currently read in the Simplifier only.
#       I also do not want to "pollute" other perl files too much with specifics of the Simplifier.
#    2. Also certain options might become in future also target of some simplification phase.
#       Than we need to handle that option here anyway.
my $cl_snip_all   = '';
# 3. The third snip is valid(static) for all steps in one Simplification phase.
#    Example: PHASE_THREAD1_REPLAY --> "--threads=1"
my $cl_snip_phase = '';
# 3. The forth snip is valid for one simplification step/job within a simplification phase given.
#    Example: PHASE_GRAMMAR_SIMP and job M --> "--grammar=c<n>.yy"
my $cl_snip_step  = '';
#
# The assembling will be like
#    rqg.pl <cl_snip_not_here1> $cl_snip_all $cl_snip_phase $cl_snip_step <cl_snip_not_here2>
#
# (*) In case of options where the last settings overwrites any setting before in call line
#     simplification phases can do temporary or permanent contradicting settings.
#     Example1: $cl_snip_all contains "--threads=10"
#               PHASE_THREAD1_REPLAY sets $cl_snip_phase = "... --threads=1"
#     Example2: Lets assume that PHASE_THREAD1_REPLAY reveals that we can replay with threads=1.
#               Than we could append a " --threads=1" to $cl_snip_all.

my $duration;
use constant DURATION_DEFAULT           => 300;
my $duration_adaption;
use constant DURATION_ADAPTION_NONE     => 'None';
use constant DURATION_ADAPTION_MAX_MID  => 'MaximumMiddle';
use constant DURATION_ADAPTION_MAX      => 'Maximum';
use constant DURATION_ADAPTION_EXP      => 'Experimental';

my $grammar_flags;

my $parent_number = 0; # Contains the number of the next parent grammar to be generated.
my $parent_grammar;    # Contains the name (no path) of the last parent grammar generated.
my $grammar_string;
my $grammar_structure;
#
my $child_number  = 0;  # Contains the number of the next last child grammar to be generated.
my $child_grammar;      # Contains the name (no path) of the last child grammar generated.
#
my $best_grammar  = 'best_grammar.yy'; # The best of the replaying grammars.

sub get_shrinked_rvt_options;

# $ever_success
# -------------
# Set to 1 in case the problem was replayed.
# Used for deciding if to run certain phases of simplification at all or not.
# (at least in the moment theoretical) Example:
# In case we had no replay in the phase PHASE_FIRST_REPLAY than switching to certain other
# phases makes no sense.
# Up till now its unsure if the variable is really required.
my $ever_success = 0;


# Campaigns within the phase PHASE_GRAMMAR_SIMP and required variables
# ====================================================================
# $out_of_ideas
# -------------
# Some state within a grammar simplification campaign or during reporter/validator/transformer
# simplification.
# Starting at some point all thinkable orders for simplifying some grammar were generated and
# this variable will be than set to 1.
# my $out_of_ideas = 0;
#
# $campaign_success
# -----------------
# Set to
# - 0 when starting some campaign
# - incremented in case the problem was replayed within the current campaign.
# Used for deciding if to run some next campaign or not.
# Example:
# Phase is PHASE_GRAMMAR_SIMP
# In case we had during the last campaign (== Try to remove alternatives from grammar rules)
# success at all and we have tried all possible simplifications at least once tjan it makes
# sense to repeat such a campaign. This is especially important for concurrency bugs.
my $campaign_success = 0;
#
# $campaign_number
# ----------------
# Incremented whenever such a campaign gets started.
my $campaign_number  = 0;
#
# $campaign_number
# ----------------
# Incremented whenever such a campaign gets started.
my $refill_number    = 0;


# Additional parameters maybe being target of simplification
my $rvt_options = '';
my @reporter_array;
my %reporter_hash;
my @transformer_array;
my %transformer_hash;
my @validator_array;
my %validator_hash;

my $simplify_chain;
my @simp_chain;

# Replay Runtime fifo
# Replay duration fifo


$| = 1;


sub init {
    ($config_file, $workdir) = @_;
    # Based on the facts that
    # - Combinator/Simplifier init gets called before any Worker is running
    # - this init will be never called again
    # we can run safe_exit($status) and do not need to initiate an emergency_exit.
    #
    if (2 != scalar @_) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: Simplifier::init : Two parameters " .
                    "(config_file, workdir) are required.");
        safe_exit($status);
    }

    Carp::cluck("# " . isoTimestamp() . " DEBUG: Simplifier::init : Entering routine with " .
                "variables (config_file, workdir).\n") if Auxiliary::script_debug("S1");

    # Check the easy stuff first.
    if (not defined $config_file) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNALE ERROR: Simplifier::init : config file is undef. " .
                    Auxiliary::exit_status_text($status));
        safe_exit($status);
    }
    if (not -f $config_file) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: Simplifier::init : The config file '$config_file' does not exist or is not " .
            "a plain file. " . Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

    if (not defined $workdir) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNALE ERROR: Simplifier::init : workdir is undef. " .
                    Auxiliary::exit_status_text($status));
        safe_exit($status);
    }
    if (not -d $workdir) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: Simplifier::init : The workdir '$workdir' does not exist or is not " .
            "a directory. " . Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

    my $config_file_copy = $workdir . "/" . $config_file_copy_rel;
    if (not File::Copy::copy($config_file, $config_file_copy)) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: Copying the config file '$config_file' to '$config_file_copy' failed : $!. " .
            Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

# ---------------------------------------------

    my $queries;

    say("DEBUG: Command line content left over after being processed by rqg_batch.pl : " .
        join(" ", @ARGV)) if Auxiliary::script_debug("S4");

    # Read the command line options which are left over after being processed by rqg_batch.
    # -------------------------------------------------------------------------------------
    # Hints:
    # 1. Code                       | Command line        |  Impact
    #    'variable=s' => \$variable   --variable= --var2     --> $variable is undef
    #    'variable:s' => \$variable   --variable= --var2     --> $variable is defined and ''
    # 2. rqg_batch.pl does not process the config file content.
    my $options = {};
    Getopt::Long::Configure('pass_through');
    if (not GetOptions(
        $options,
    #   'help'                      => \$help,                  # Swallowed and handled by rqg_batch. Only there?
    #   'type=s'                    => \$type,                  # Swallowed and handled by rqg_batch
    #   'config=s'                  => \$config_file,           # Swallowed and checked by rqg_batch. Got here as parameter
####    'basedir=s'                 => \$basedirs[0],
    #   'basedir1=s'                => \$basedirs[1],           # Swallowed and handled by rqg_batch
    #   'basedir2=s'                => \$basedirs[2],           # Swallowed and handled by rqg_batch
    #   'basedir3=s'                => \$basedirs[3],           # Swallowed and handled by rqg_batch
    #   'workdir=s'                 => \$workdir,               # Swallowed and handled by rqg_batch. Got here as parameter
    #   'vardir=s'                  => \$vardir,                # Swallowed and handled by rqg_batch
    #   'build_thread=i'            => \$build_thread,          # Swallowed and handled by rqg_batch
        'trials=i'                  ,                           # Handled here (max no of finished trials for certain phases only)
        'duration=i'                ,                           # Handled here
        'queries=i'                 ,                           # Handled here
#       'seed=s'                    => \$seed,                  # Handled(Ignored!) here
    #   'force'                     => \$force,                 # Swallowed and handled by rqg_batch
#         'no-mask'                   => \$no_mask,             # Not supported!
        'grammar=s'                 => \$grammar_file,          # Handle here. Requirement caused by Simplifier
    #   'gendata=s'                 => \$gendata,               # Rather handle here
    #   'testname=s'                => \$testname,              # Swallowed and handled by rqg_batch
    #   'xml-output=s'              => \$xml_output,            # Swallowed and handled by rqg_batch
    #   'report-xml-tt'             => \$report_xml_tt,         # Swallowed and handled by rqg_batch
    #   'report-xml-tt-type=s'      => \$report_xml_tt_type,    # Swallowed and handled by rqg_batch
    #   'report-xml-tt-dest=s'      => \$report_xml_tt_dest,    # Swallowed and handled by rqg_batch
    #   'run-all-combinations-once' => \$exhaustive,            # For Combinator only
    #   'start-combination=i'       => \$start_combination,     # For Combinator only
    #   'no-shuffle'                => \$noshuffle,             # For Combinator only
    #   'max_runtime=i'             => \$max_runtime,           # Swallowed and handled by rqg_batch
                                                                # Should rqg_batch ask for summary ?
    #   'dryrun=s'                  => \$dryrun,                # Swallowed and handled by rqg_batch
    #   'no-log'                    => \$noLog,                 # Swallowed and handled by rqg_batch
    #   'parallel=i'                => \$workers,               # Swallowed and handled by rqg_batch
    # runner
    # Having a --runner=<value> in a cc file + rqg_batch transforms that finally to a valid call
    # of that RQG runner is thinkable.
    # But why going with that complexity just for allowing to have a crowd of RQG runs with
    # partially differing RQG runners?
    # A user could also distribute these runs over several rqg_batch.pl calls with differing config files.
    #   'runner=s'                  => \$runner,                # Swallowed and handled by rqg_batch
    #   'stop_on_replay'            => \$stop_on_replay,        # Swallowed and handled by rqg_batch
    #   'servers=i'                 => \$servers,               # Swallowed and handled by rqg_batch
        'threads=i'                 ,                           # Handled here (placed in cl_snip)
    #   'discard_logs'              => \$discard_logs,          # Swallowed and handled by rqg_batch
    #   'discard-logs'              => \$discard_logs,          # Swallowed and handled by rqg_batch
    #   'script_debug=s'            => \$script_debug,          # Swallowed and handled by rqg_batch
    #   'runid:i'                   => \$runid,                 # No use here
        'simplify_chain:s'          => \$simplify_chain,        # For grammar simplifier only.
        'algorithm:s'               => \$algorithm,             # For grammar simplifier only.
                                                       )) {
        # Somehow wrong option.
        # help_simplifier();
        my $status = STATUS_ENVIRONMENT_FAILURE;
        safe_exit($status);
    };
    my $argv_remain = join(" ", @ARGV);
    if (defined $argv_remain and $argv_remain ne '') {
        say("WARN: The following command line content is left over ==> gets ignored. ->$argv_remain<-");
    }

    # Read the options found in config_file.
    # --------------------------------------
    # We work with the copy only!
    # config_file_copy
    #   'seed=s'                    => \$seed,                  # Handled here
    $options->{'config'} = $config_file_copy;
    my $config = GenTest::Properties->new(
        options     => $options,
        legal       => [
                    'grammar',                                  # Handled
#                   'redefine',
                    'grammar_flags',
#                   'gendata',
#                   'gendata_sql',
                    'rqg_options',
                    'validators',
                    'reporters',
                    'transformers',
                    'workdir',
                    'threads',                                  # Handled
                    'queries',                                  # Handled
                    'duration',                                 # Handled
                    'duration_adaption',                        # Handled
                    'trials',                                   # Handled
                    'algorithm',
                    'search_var_size',
                    'simplify_chain',
                    'whitelist_statuses',
                    'whitelist_patterns',
                    'blacklist_statuses',
                    'blacklist_patterns',
        ],
        required    => [
                    'rqg_options',
        ],
        defaults    => {
                    'algorithm'         => SIMP_ALGO_WEIGHT,
                    'trials'            => TRIALS_DEFAULT,
                    'duration'          => DURATION_DEFAULT,
                    'queries'           => QUERIES_DEFAULT,
                    'threads'           => THREADS_DEFAULT,
                    'validators'        => 'None',
                    'grammar_flags'     => undef,
                    'duration_adaption' => DURATION_ADAPTION_MAX,
                    'search_var_size'   => 100000000,
                    'simplify_chain'    => \@simp_chain_default,
        }
    );

    if (defined $simplify_chain) {
        if ($simplify_chain eq '' or lc($simplify_chain) eq 'default' ) {
            say("INFO: simplify_chain is '$simplify_chain' hence loading the default chain.");
            @simp_chain = @simp_chain_default;
        } else {
            $simplify_chain = Auxiliary::input_to_list($simplify_chain);
            if (not defined $simplify_chain) {
                # Auxiliary::input_to_list delivered undef because of trouble (already reported).
                safe_exit(99);
            }
            @simp_chain = @$simplify_chain;
        }
    } else {
        if (defined $config->simplify_chain) {
            @simp_chain = @{$config->simplify_chain};
        }
    }

    say("INFO: simp_chain : '" . join("' ==> '",@simp_chain) . "'");
    foreach my $phase_c (@simp_chain) {
        my $result = Auxiliary::check_value_supported ('simplify_chain',
                                                       PHASE_SIMP_ALLOWED_VALUE_LIST, $phase_c);
        if ($result != STATUS_OK) {
            safe_exit(99);
        }
    }

    @simp_chain = (PHASE_SIMP_BEGIN, @simp_chain);
    push @simp_chain, PHASE_SIMP_END;

    # Note
    # ----
    # $grammar (value taken from ARGV)
    # $config->grammar (value taken from config file top level variables)
    # $config->rqg_options->{grammar} (value taken from config file rqg_options section)
    # get_job returns some command line snip to the caller.
    # Around the end of that snip can be a ' --grammar=<dynamic decided grammar>'.
    # The grammar here is only the initial grammar to be used at begin of simplification process.

    $config->printProps();
    my $rqg_options_begin = $config->genOpt('--', 'rqg_options');

    my $warn1 = "WARN: The grammar file finally used is the one found on highest level (" .
                "command line, config file top level, config file rqg_option section).\n" .
                "WARN: All assignments to redefine/mask/mask_level on any level will get ignored.";
    my $warn2 = '';
    if (defined $grammar_file and $grammar_file ne '') {
        my $info = "Grammar '$grammar_file' was assigned via rqg_batch.pl call.";

        say("DEBUG: $info") if Auxiliary::script_debug("S2");
        $warn1 .= "\nINFO: $info";

        # Only $grammar (and not redefine, mask*) is allowed in config file top level.
        my $other = $config->grammar;
        if (defined $other) {
            $warn2 .= "\nWARN: Removing the grammar assignment in config file top level.";
            $config->unsetProperty('grammar');
        }
        if (exists $config->rqg_options->{'grammar'}) {
            $warn2 .= "\nWARN: Removing the grammar assignment inside of the RQG options section.";
            delete $config->rqg_options->{'grammar'};
        }
    } else {
        $grammar_file = $config->grammar;
        if (defined $grammar_file and $grammar_file ne '') {
            my $info = "Grammar '$grammar_file' was assigned in config file top level.";
            say("DEBUG: $info") if Auxiliary::script_debug("S2");
            $warn1 .= "\nINFO: $info";

            if (exists $config->rqg_options->{'grammar'}) {
                $warn2 .= "\nWARN: Removing the grammar assignment inside of the RQG options section.";
                delete $config->rqg_options->{'grammar'};
            }
        } else {
            $grammar_file = $config->rqg_options->{'grammar'};
            if (defined $grammar_file and $grammar_file ne '') {
                my $info = "Grammar '$grammar_file' was assigned in config file rqg_option section.";
                say("DEBUG: $info") if Auxiliary::script_debug("S2");
                $warn1 .= "\nINFO: $info";
            } else {
                my $status = STATUS_ENVIRONMENT_FAILURE;
                say("ERROR: Grammar neither via command line nor via config file assigned. " .
                Auxiliary::exit_status_text($status));
                safe_exit($status);
            }
        }
    }

    # Any assignments of redefine, mask and mask_level (only possible in RQG options section
    # of config file must get ignored.
    if (exists $config->rqg_options->{'redefine'}) {
        $warn2 .= "\nWARN: Removing the redefine assignment inside of the RQG options section.";
        delete $config->rqg_options->{'redefine'};
    }
    if (exists $config->rqg_options->{'mask'}) {
        $warn2 .= "\nWARN: Removing the mask assignment inside of the RQG options section.";
        delete $config->rqg_options->{'mask'};
    }
    if (exists $config->rqg_options->{'mask_level'}) {
        $warn2 .= "\nWARN: Removing the mask_level assignment inside of the RQG options section.";
        delete $config->rqg_options->{'mask_level'};
    }
    if (exists $config->rqg_options->{'no_mask'}) {
        delete $config->rqg_options->{'no_mask'};
    }

    if ($warn2 ne '') {
        say($warn1 . $warn2);
    }

    # $trials cannot be in the command line snip.
    $trials =        $config->trials;
    my $bad_trials = $config->rqg_options->{'trials'};
    if (defined $bad_trials) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: trials found between 'rqg_options'. This is wrong. Abort. " .
            Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

    # $duration could be part of the command line snip.
    # But the value here is only the base for the computation of the
    # ' --duration=<dynamic decided value>' added to the end of that snip.
    $duration = $config->duration;
    if (defined $duration and $duration >= 0) {
        say("DEBUG: duration '$duration' was assigned via rqg_batch.pl call or " .
            "within config file top level.\n" .
            "DEBUG: Wiping all other occurrences of settings for duration.")
            if Auxiliary::script_debug("S2");
        delete $config->rqg_options->{'duration'};
    } else {
        $duration = $config->rqg_options->{'duration'};
        if (defined $duration and $duration >= 0) {
            say("DEBUG: duration '$duration' was assigned in config file rqg_option section. " .
                "Wiping all other occurrences of settings for duration.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'duration'};
        } else {
            my $status = STATUS_ENVIRONMENT_FAILURE;
            say("ERROR: duration neither via command line nor via config file assigned. " .
            Auxiliary::exit_status_text($status));
            safe_exit($status);
        }
    }
    $cl_snip_all .= " --duration=" . $duration;

    # $duration_adaption cannot be in the command line snip.
    # But it has an impact during computation of the ' --duration=<dynamic decided value>'
    # added to the end of that snip later.
    $duration_adaption = $config->duration_adaption;
    my $bad_duration_adaption = $config->rqg_options->{'duration_adaption'};
    if (defined $bad_duration_adaption) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: duration_adaption found between 'rqg_options'. This is wrong. Abort. " .
            Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

    # $queries can be in the the command line snip.
    $queries = $config->queries;
    if (defined $queries and $queries >= 0) {
        say("DEBUG: queries '$queries' was assigned via rqg_batch.pl call or " .
            "within config file top level.\n" .
            "DEBUG: Wiping all other occurrences of settings for queries.")
            if Auxiliary::script_debug("S2");
        delete $config->rqg_options->{'queries'};
    } else {
        $queries = $config->rqg_options->{'queries'};
        if (defined $queries and $queries >= 0) {
            say("DEBUG: queries '$queries' was assigned in config file rqg_option section. " .
                "Wiping all other occurrences of settings for queries.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'queries'};
        } else {
            my $status = STATUS_ENVIRONMENT_FAILURE;
            say("ERROR: queries neither via command line nor via config file assigned. " .
            Auxiliary::exit_status_text($status));
            safe_exit($status);
        }
    }
    $cl_snip_all .= " --queries=" . $queries;

    # $threads can be in the command line snip.
    # ' --threads=$threads' added to the end of that snip except ' --threads=1' is
    # added from whatever reason.
    $threads = $config->threads;
    if (defined $threads and $threads >= 0) {
        say("DEBUG: threads '$threads' was assigned via rqg_batch.pl call or " .
            "within config file top level.\n" .
            "DEBUG: Wiping all other occurrences of settings for threads.")
            if Auxiliary::script_debug("S2");
        delete $config->rqg_options->{'threads'};
    } else {
        $threads = $config->rqg_options->{'threads'};
        if (defined $threads and $threads >= 0) {
            say("DEBUG: threads '$threads' was assigned in config file rqg_option section. " .
                "Wiping all other occurrences of settings for threads.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'threads'};
        } else {
            my $status = STATUS_ENVIRONMENT_FAILURE;
            say("ERROR: threads neither via command line nor via config file assigned. " .
            Auxiliary::exit_status_text($status));
            safe_exit($status);
        }
    }
    $cl_snip_all .= " --threads=" . $threads;

    # This parameter could be part of the command line snip.
    $algorithm = $config->algorithm;
    my $bad_algorithm = $config->rqg_options->{'algorithm'};
    if (defined $bad_algorithm) {
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("ERROR: algorithm found between 'rqg_options'. This is wrong. Abort. " .
            Auxiliary::exit_status_text($status));
        safe_exit($status);
    }

    # Add it in order to be sure that the grammar gets not mangled per mistake.
    $cl_snip_all .= " --no_mask";
    delete $config->rqg_options->{'no_mask'};

    # Add it in order to be sure that we work with maximum randomness.
    # This is especially important for PHASE_THREAD1_REPLAY where we go with thread=1.
    # Per experience there is also some smaller but not negligible impact if going with significant
    # higher number of threads.
    $cl_snip_all .= " --seed=random";
    delete $config->rqg_options->{'seed'};

    ###
    my $mysql_options = '';
    foreach my $val ('', '1', '2', '3', '4', '5') {
        my $section = "mysqld" . $val;
        if(exists $config->rqg_options->{$section}) {
            say("DEBUG: A '$section' section exists.") if Auxiliary::script_debug("S5");
            $mysql_options .= $config->genOpt("--$section=--", $config->rqg_options->{$section});
            delete $config->rqg_options->{$section};
        }
    }
    say("DEBUG: mysql_options ->$mysql_options<-") if Auxiliary::script_debug("S4");

    # $config->reporters , $config->validators and $config->transformers are all pointers to
    # corresponding arrays.
    my $reporters = $config->reporters;
    if (defined $reporters) {
        if (defined $config->rqg_options->{'reporters'}) {
            say("WARN: Wiping the settings for reporters within the rqg options because other " .
                "(command line or top level in config file) exist and have precedence.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'reporters'};
        }
    } else {
        $reporters = $config->rqg_options->{'reporters'};
        delete $config->rqg_options->{'reporters'};
        if (not defined $reporters) {
            my $status = STATUS_ENVIRONMENT_FAILURE;
            say("ERROR: Reporters neither via command line nor via config file reporters " .
                "assigned. But the Simplifier should not guess what the RQG runner will do." .
            Auxiliary::exit_status_text($status));
            safe_exit($status);
        }
    }
    my $array_ref;
    my $hash_ref;
    ($array_ref, $hash_ref) = Auxiliary::unify_rvt_array($reporters);
    @reporter_array = @{$array_ref};
    %reporter_hash  = %{$hash_ref};
    # say("DEBUG: Reporters : ->" . join("<->", @reporter_array) . "<-") if Auxiliary::script_debug("S2");
    # For experimenting:
    # %reporter_hash  = ();
    say("DEBUG: Reporters : ->" . join("<->",  sort keys %reporter_hash) . "<-")
        if Auxiliary::script_debug("S2");

    my $validators = $config->validators;
    if (defined $validators) {
        if (defined $config->rqg_options->{'validators'}) {
            say("WARN: Wiping the settings for validators within the rqg options because other " .
                "(command line or top level in config file) exist and have precedence.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'validators'};
        }
    } else {
        $validators = $config->rqg_options->{'validators'};
        delete $config->rqg_options->{'validators'};
    }
    ($array_ref, $hash_ref) = Auxiliary::unify_rvt_array($validators);
    @validator_array = @{$array_ref};
    %validator_hash  = %{$hash_ref};
    # say("DEBUG: Validators : ->" . join("<->", @validator_array) . "<-") if Auxiliary::script_debug("S2");
    say("DEBUG: Validators : ->" . join("<->",  sort keys %validator_hash) . "<-")
        if Auxiliary::script_debug("S2");

    my $transformers = $config->transformers;
    if (defined $transformers) {
        if (defined $config->rqg_options->{'transformers'}) {
            say("WARN: Wiping the settings for transformers within the rqg options because other " .
                "(command line or top level in config file) exist and have precedence.")
            if Auxiliary::script_debug("S2");
            delete $config->rqg_options->{'transformers'};
        }
    } else {
        $transformers = $config->rqg_options->{'transformers'};
        delete $config->rqg_options->{'transformers'};
    }
    ($array_ref, $hash_ref) = Auxiliary::unify_rvt_array($transformers);
    @transformer_array = @{$array_ref};
    %transformer_hash  = %{$hash_ref};
    # say("DEBUG: Transformers : ->" . join("<->", @transformer_array) . "<-") if Auxiliary::script_debug("S2");
    say("DEBUG: Transformers : ->" . join("<->",  sort keys %transformer_hash) . "<-")
        if Auxiliary::script_debug("S2");

    # say("RVT options : " . get_shrinked_rvt_options); --> abort
    # say("RVT options : " . get_shrinked_rvt_options(undef)); --> abort
    # say("RVT options : " . get_shrinked_rvt_options(undef, 'A')); --> abort
    # say("RVT options : " . get_shrinked_rvt_options(1, undef)); --> abort
    # say("RVT options : " . get_shrinked_rvt_options(undef,undef)); --> get string
    # say("RVT options : " . get_shrinked_rvt_options('omo','omo')); --> abort
    # say("RVT options : " . get_shrinked_rvt_options('reporter','omo')); --> undef
    # say("RVT options : " . get_shrinked_rvt_options('reporter','Backtrace'));
    # say("RVT options : " . get_shrinked_rvt_options('reporter','ErrorLog'));
    # say("RVT options : " . get_shrinked_rvt_options('transformer','None'));

    my $rqg_options_end = $config->genOpt('--', 'rqg_options');
    if (Auxiliary::script_debug("S5")) {
        say("DEBUG: RQG options before 'mangling' ->$rqg_options_begin<-");
        say("DEBUG: RQG options after  'mangling' ->$rqg_options_end<-");
    }

    if (STATUS_OK != Verdict::check_normalize_set_black_white_lists (
                    ' The RQG run ended with status ', # $status_prefix,
                    $config->blacklist_statuses, $config->blacklist_patterns,
                    $config->whitelist_statuses, $config->whitelist_patterns)) {
        say("ERROR: Setting the values for blacklist and whitelist search failed.");
        # my $status = STATUS_CONFIG_ERROR;
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("$0 will exit with exit status " . status2text($status) . "($status)");
        safe_exit($status);
    }

    if (not defined $grammar_file) {
        say("ERROR: Grammar file is not defined.");
        help_simplifier();
        my $status = STATUS_ENVIRONMENT_FAILURE;
        say("$0 will exit with exit status " . status2text($status) . "($status)");
        safe_exit($status);
    } else {
        if (! -f $grammar_file) {
            say("ERROR: Grammar file '$grammar_file' does not exist or is not a plain file.");
            help_simplifier();
            my $status = STATUS_ENVIRONMENT_FAILURE;
            say("$0 will exit with exit status " . status2text($status) . "($status)");
            safe_exit($status);
        }
    }
    $grammar_flags = $config->grammar_flags;

    # Actions of GenTest::Simplifier::Grammar_advanced::init
    # ...  load_grammar($grammar_file);
    # ...  fill_rule_hash();
    # ...  print_rule_hash();
    # ...  analyze_all_rules(); -- Maintains counter except weight and removes unused rules
    # ...  compact_grammar();   -- collapseComponents (unique) and moderate inlining
    $grammar_string = GenTest::Simplifier::Grammar_advanced::init($grammar_file, $threads,
                                                                  10, $grammar_flags);
    # Aborts if
    # - $grammar_string is not defined
    # - creation of parent grammar file fails
    make_parent_from_string ($grammar_string);
    say("Grammar ->$grammar_string<-") if Auxiliary::script_debug("S4");

    $result_file  = $workdir . "/result.txt";
    my $iso_ts = isoTimestamp();
    my $g_flags;
    if (not defined $grammar_flags) {
        $g_flags = '<undef>';
    } else {
        $g_flags = $grammar_flags;
    }
    my $header =
"$iso_ts Simplifier init ================================================================================================\n" .
"$iso_ts workdir                                         : '$workdir'\n"                                                     .
"$iso_ts config_file (assigned)                          : '$config_file'\n"                                                 .
"$iso_ts config file (processed + is copy of above)      : '$config_file_copy_rel'\n"                                        .
"$iso_ts duration (maybe adjusted during simplification) : $duration seconds (Default " . DURATION_DEFAULT . ")\n"           .
"$iso_ts queries                                         : $queries (Default " . QUERIES_DEFAULT . ")\n"                     .
"$iso_ts threads                                         : $threads (Default " . THREADS_DEFAULT . ")\n"                     .
"$iso_ts initial grammar file                            : '$grammar_file'\n"                                                .
"$iso_ts reporters                                       : " . join(",", @reporter_array) . "\n"                             .
"$iso_ts validators                                      : " . join(",", @validator_array) . "\n"                            .
"$iso_ts transformers                                    : " . join(",", @transformer_array) . "\n"                          .
"$iso_ts ----------------------------------------------------------------------------------------------------------------\n" .
"$iso_ts trials (used for certain phases only)                   : $trials (Default " . TRIALS_DEFAULT . ")\n"               .
"$iso_ts duration_adaption (vary duration according to progress) : $duration_adaption (Default 1)\n"                         .
"$iso_ts algorithm (used for grammar simplification)             : '$algorithm' (Default '" . SIMP_ALGO_WEIGHT . "')\n"      .
"$iso_ts grammar_flags                                           : $g_flags (Default undef)\n"                               .
"$iso_ts ----------------------------------------------------------------------------------------------------------------\n" .
"$iso_ts call line additions (bwlist excluded) : $cl_snip_all\n"                                                             .
"$iso_ts ----------------------------------------------------------------------------------------------------------------\n" .
"$iso_ts whitelist_statuses : " . join(',',@{$config->whitelist_statuses}) . "\n"                                            .
"$iso_ts whitelist_patterns : " . join(',',@{$config->whitelist_patterns}) . "\n"                                            .
"$iso_ts blacklist_statuses : " . join(',',@{$config->blacklist_statuses}) . "\n"                                            .
"$iso_ts blacklist_patterns : " . join(',',@{$config->blacklist_patterns}) . "\n"                                            .
"$iso_ts ----------------------------------------------------------------------------------------------------------------\n" ;
    Batch::write_result($header);

    $cl_snip_all .= " " . $rqg_options_end . " " . $mysql_options .
                    Verdict::black_white_lists_to_config_snip('cl');

    replay_runtime_fifo_init(10, $duration);

    $phase        = shift @simp_chain;
    $phase_switch = 1;

    say("DEBUG: Leaving 'Simplifier::init") if Auxiliary::script_debug("S6");


} # End sub init


sub get_job {
    my $order_id;
    my @job;
# In lib/Batch.pm
# use constant JOB_CL_SNIP    => 0;
# use constant JOB_ORDER_ID   => 1;
# use constant JOB_MEMO1      => 2;  # Child  grammar or Child rvt_snip
# use constant JOB_MEMO2      => 3;  # Parent grammar or Parent rvt_snip
# use constant JOB_MEMO3      => 4;  # Adapted duration

    # Safety measure
    my ($active) = @_;

    # For experimenting:
    # $active = 10;
    if ($phase_switch) {
        if(not defined $active or 0 != $active) {
            my $status = STATUS_INTERNAL_ERROR;
            Carp::cluck("INTERNAL ERROR: Wrong call of Simplifier::getjob : active is not 0.");
            Batch::emergency_exit($status);
        } else {
            if ($phase eq PHASE_SIMP_END) {
                $Batch::give_up = 2;
                return undef;
            }
            switch_phase();
            # Setting $phase_switch = 0 is made in switch_phase().
        }
    }

    while (not defined $order_id) {
        say("DEBUG: Begin of loop for getting an order.") if Auxiliary::script_debug("S6");
        $order_id = Batch::get_order();
        if (defined $order_id) {
            say("DEBUG: Batch::get_order delivered order_id $order_id.")
                if Auxiliary::script_debug("S6");
            my $order_is_valid = 0;
                if (PHASE_FIRST_REPLAY   eq $phase or
                    PHASE_THREAD1_REPLAY eq $phase or
                    PHASE_FINAL_REPLAY   eq $phase   ) {
                    # Any order is valid. The sufficient enough tried were already sorted out above.
                    $order_is_valid = 1;
                    # The grammar to be used is the parent grammar when entering the phase.
                    $job[Batch::JOB_CL_SNIP]  = $cl_snip_all . $cl_snip_phase .
                                         " --grammar=" . $workdir . "/" . $child_grammar;
                    $job[Batch::JOB_ORDER_ID] = $order_id;
                    $job[Batch::JOB_MEMO1]    = undef;     # undef or Child grammar or
                                                           # Child rvt_snip
                    $job[Batch::JOB_MEMO2]    = undef;     # undef or Parent grammar or
                                                           # Parent rvt_snip
                    $job[Batch::JOB_MEMO3]    = undef;     # undef or Adapted duration
                } elsif (PHASE_RVT_SIMP eq $phase) {
                    my $option_to_attack = $order_array[$order_id][ORDER_PROPERTY2];
                    my $value_to_remove  = $order_array[$order_id][ORDER_PROPERTY3];
                    my $cl_snip_step     = get_shrinked_rvt_options($option_to_attack,
                                                                    $value_to_remove, 0);
                    if (not defined $cl_snip_step) {
                        say("DEBUG: Order id '$order_id' with option_to_attack " .
                            "'$option_to_attack' value_to_remove '$value_to_remove' is invalid.")
                            if Auxiliary::script_debug("S4");
                        $order_is_valid = 0;
                        Batch::add_to_try_never($order_id);
                        $order_id = undef;
                    } else {
                        my $cl_snip_parent = get_shrinked_rvt_options(undef, undef, 0);
                        $job[Batch::JOB_CL_SNIP]  = $cl_snip_all . $cl_snip_phase . $cl_snip_step .
                                             " --grammar=" . $workdir . "/" . $child_grammar;
                        $job[Batch::JOB_ORDER_ID] = $order_id;
                        $job[Batch::JOB_MEMO1]    = $cl_snip_step;
                        $job[Batch::JOB_MEMO2]    = $cl_snip_parent;
                        $job[Batch::JOB_MEMO3]    = undef;
                    }
                } elsif (PHASE_GRAMMAR_SIMP eq $phase or
                         PHASE_GRAMMAR_DEST eq $phase   ) {
                    my $rule_name        = $order_array[$order_id][ORDER_PROPERTY2];
                    my $component_string = $order_array[$order_id][ORDER_PROPERTY3];
                    my $dtd_protection   = 0;
                    say("DEBUG: Simplifier::order_is_valid : rule_name '$rule_name', component ->" .
                        $component_string . "<-") if Auxiliary::script_debug("S5");
                    my $new_rule_string = GenTest::Simplifier::Grammar_advanced::shrink_grammar(
                             $rule_name, $component_string, $dtd_protection);
                    if (defined $new_rule_string) {
                        $child_grammar = "c" . Auxiliary::lfill0($child_number,5) . ".yy";
                        Batch::make_file($workdir . "/" . $child_grammar, $grammar_string .
                                         "\n\n# Generated by grammar simplifier\n" .
                                         $new_rule_string . "\n");
                        $child_number++;
                        $order_is_valid = 1;
                        my $duration_a     = replay_runtime_adapt();
                        $job[Batch::JOB_CL_SNIP]  = $cl_snip_all . $cl_snip_phase . $cl_snip_step .
                                             " --grammar=" . $workdir . "/" . $child_grammar .
                                             " --duration=$duration_a";
                        $job[Batch::JOB_ORDER_ID] = $order_id;
                        $job[Batch::JOB_MEMO1]    = $child_grammar;
                        $job[Batch::JOB_MEMO2]    = $parent_grammar;
                        $job[Batch::JOB_MEMO3]    = $duration_a;
                    } else {
                        say("DEBUG: Order id '$order_id' affecting rule '$rule_name' component " .
                            "'$component_string' is invalid.") if Auxiliary::script_debug("S4");
                        $order_is_valid = 0;
                        Batch::add_to_try_never($order_id);
                        $order_id = undef;
                    }
                } elsif (PHASE_SIMP_END eq $phase) {
                } else {
                    Carp::cluck("INTERNAL ERROR: Handling for phase '$phase' is missing.");
                    my $status = STATUS_INTERNAL_ERROR;
                    Batch::emergency_exit($status);
                }
        } else {
            # NO ORDER GOT
            say("DEBUG: Batch::get_order delivered an undef order_id.")
                if Auxiliary::script_debug("S5");
            # %try_first_hash and @try_queue were empty and so $order_id is undef.
            if (PHASE_RVT_SIMP     eq $phase or PHASE_GRAMMAR_SIMP eq $phase or
                PHASE_GRAMMAR_DEST eq $phase                                    ) {
                if (5 > $refill_number) {
                    $refill_number++;
                    Batch::reactivate_try_replayer;
                    Batch::reactivate_try_over;
                    Batch::reactivate_try_over_bl;
                    Batch::reactivate_till_filled;
                    say("DEBUG: \@try_queue refill : $refill_number")
                        if Auxiliary::script_debug("S3");
                } else {
                    say("DEBUG: No \@try_queue refill. Limit of $refill_number already reached.")
                        if Auxiliary::script_debug("S3");
                    last;
                }
            } else {
                Batch::reactivate_till_filled;
                say("DEBUG: \@try_queue refilled.") if Auxiliary::script_debug("S3");
            }
            # FIXME: Is that right?
            # This implies Batch::get_out_of_ideas() > 0;
            last;
        }
        say("DEBUG: End of loop for getting an order.") if Auxiliary::script_debug("S6");
    } # End of while (not defined $order_id)
    if (Auxiliary::script_debug("S6")) {
        if (defined $order_id) {
            say("DEBUG: OrderID is $order_id.");
        } else {
            if (0 == Batch::get_out_of_ideas()) {
                say("WARN: OrderID is not defined AND Batch::out_of_ideas is 0.");
            }
        }
    }

    if (not defined $order_id) {
        # %try_first_hash empty , %try_hash empty too and extending obviously impossible
        # because otherwise %try_hash would be not empty.
        # == All possible orders were generated.
        #    Some might be in execution and all other must be in %try_over_hash or
        #    %try_never_hash.
        say("DEBUG: No order got, active : $active, out_of_ideas : " . Batch::get_out_of_ideas())
            if Auxiliary::script_debug("S5");
        Batch::dump_try_hashes() if Auxiliary::script_debug("S6");
        if (not $active and Batch::get_out_of_ideas()) {
            $phase_switch     = 1;
            say("DEBUG: Simplifier::get_job : No valid order found, active : $active, " .
                "out_of_ideas : " . Batch::get_out_of_ideas() . " --> Set phase_switch = 1 " .
                "and return undef") if Auxiliary::script_debug("S5");
        }
        return undef;
    } else {
        if (not defined $order_array[$order_id]) {
            my $status = STATUS_INTERNAL_ERROR;
            Carp::cluck("INTERNALE ERROR: Simplifier::get_job : orderid is not in order_array. " .
                        "Will exit with status " . status2text($status) . "($status)");
            Batch::emergency_exit($status);
        }
        # Prepare the job according to phase
        return @job;
    }

} # End of get_job


sub help() {
print("\n" .
"The information here is only about parameters/options which\n"                                    .
"- can be assigned to rqg_batch.pl at command line and\n"                                          .
"- have an impact on the simplification process\n\n"                                               .
"Information about other parameters/options which can be assigned within the config file (*.cfg) " .
"is provided there as comment.\n\n"                                                                .
"trials\n"                                                                                         .
"   Maximum number of trials to replay the desired outcome in certain simplification phases\n"     .
"   Default: " . TRIALS_DEFAULT . "\n"                                                             .
"duration\n"                                                                                       .
"   Maximum YY grammar processing runtime assigned to the call of the RQG runner\n"                .
"   The simplification phase '" . PHASE_GRAMMAR_SIMP . "' might manipulate that value.\n"          .
"   Default: " . DURATION_DEFAULT . "\n"                                                           .
"threads\n"                                                                                        .
"   Number of connections executing queries generated by YY grammar processing.\n"                 .
"   The simplification phase '" . PHASE_THREAD1_REPLAY . "' might manipulate that value.\n"        .
"   Default: " . THREADS_DEFAULT . "\n"                                                            .
"grammar (mandatory if not set in config file)\n"                                                  .
"   YY grammar file with absolute path or path relative to top level directory of RQG.\n"          .
"   In case the YY grammar gets assigned this way than any grammar maybe assigned in the config"   .
"file will get ignored.\n"                                                              .
"simplify_chain\n"                                                                                 .
"   Comma separated list of simplification phases.\n"                                              .
"   The simplifier will work in these phases and in the assigned order.\n"                         .
"   Default: '" . join("' ==> '",@simp_chain_default) . "'\n"                                      .
"algorithm\n"                                                                                      .
"   Algorithm to be used when simplifying the YY grammar.\n"                                       .
"   Currently only the per experience most effective algorithm '" . SIMP_ALGO_WEIGHT               .
"' is supported.\n"                                                                                .
"   Default: '" . SIMP_ALGO_WEIGHT . "'\n\n"                                                       .
"rqg_batch.pl passes certain parameters to the Simplifier.\n"                                      .
"Parameters settings which are finally left over and get ignored at all will be reported in a "    .
"line starting with\n"                                                                             .
"     WARNING: The following command line content is left over ...\n\n"                            .
"seed\n"                                                                                           .
"   The simplifier will ignore the assigned value and assign to every RQG run\n"                   .
"       --seed=random\n"                                                                           .
"   instead because this is per experience the most effective setting.\n\n"                        .
"Warning:\n"                                                                                       .
"The file assigned to 'grammar' will get treated as 'effective' grammar.\n"                        .
"This means any assignment of redefine/mask/mask_level will get removed/ignored and cause a "      .
"warning.\n"                                                                                       .
"'--no-mask' will be added to most RQG calls.\n"                                                   .
"\n");

}


sub print_order {

    my ($order_id) = @_;
    Batch::check_order_id($order_id);
    my @order = @{$order_array[$order_id]};
    say("$order_id  " . join ('  ', @order));

}
#
sub dump_orders {
    say("DEBUG: Content of the order array ------------- begin");
    say("id  efforts_invested  efforts_left  property1  property2  property3");
    foreach my $order_id (1..$#order_array) {
        print_order($order_id);
    }
    say("DEBUG: Content of the order array ------------- end");
}

my $have_rvt_generated = 0;
sub generate_orders {

    # Hint:
    # One call of generate_orders could add several orders!
    our $generate_calls;
    $generate_calls = 0 if not defined $generate_calls;
    $generate_calls++;
    say("DEBUG: Number of generate_orders calls : $generate_calls")
        if Auxiliary::script_debug("S5");
    Batch::dump_try_hashes() if Auxiliary::script_debug("S5");
    my $success = 0;
    # PHASE_SIMP_BEGIN        should not be relevant but is handled in the else branch
    # PHASE_FIRST_REPLAY      handled
    # PHASE_THREAD1_REPLAY    handled
    # PHASE_RVT_SIMP          handled
    # PHASE_GRAMMAR_SIMP      handled
    # PHASE_FINAL_REPLAY      handled
    # PHASE_SIMP_END
    if      (PHASE_FIRST_REPLAY   eq $phase or
             PHASE_THREAD1_REPLAY eq $phase or
             PHASE_FINAL_REPLAY   eq $phase) {
        add_order($cl_snip_all . $cl_snip_phase, 'unused', '_unused_');
        $success = 1;
    } elsif (PHASE_RVT_SIMP eq $phase) {
        # RVT_SIMP:
        # - best     'None'
        # - good     ...,'None'
        # - good     ...
        if (not $have_rvt_generated) {
            $have_rvt_generated = 1;
            sub generate_rvt_orders {
                my ($category) = @_;
                my %hash;
                if (not defined $category) {
                    Carp::cluck("INTERNAL ERROR: category is undef.");
                    my $status = STATUS_INTERNAL_ERROR;
                    Batch::emergency_exit($status);
                } elsif ('reporter' eq $category) {
                    %hash = %reporter_hash;
                } elsif ('validator' eq $category) {
                    %hash = %validator_hash;
                } elsif ('transformer' eq $category) {
                    %hash = %transformer_hash;
                } else {
                    Carp::cluck("INTERNAL ERROR: category '$category' is unknown.");
                    my $status = STATUS_INTERNAL_ERROR;
                    Batch::emergency_exit($status);
                }

                if      (0 == scalar keys %hash) {
                    add_order($cl_snip_all . $cl_snip_phase, $category, '_add_None');
                    $success++;
                } elsif (1 == scalar keys %hash) {
                    if (not exists $hash{'None'}) {
                        add_order($cl_snip_all . $cl_snip_phase, $category, '_all_to_None');
                        $success++;
                        add_order($cl_snip_all . $cl_snip_phase, $category, '_add_None');
                        $success++;
                    } else {
                        # Nothing to do because the one and only value is already 'None'.
                    }
                } else {
                    # In minimum one of the elements must be != 'None'.
                    add_order($cl_snip_all . $cl_snip_phase, $category, '_all_to_None');
                    $success++;
                    if (not exists $hash{'None'}) {
                        add_order($cl_snip_all . $cl_snip_phase, $category, '_add_None');
                        $success++;
                    }
                    foreach my $value_to_remove (keys %hash) {
                        next if $value_to_remove eq 'None';
                        add_order($cl_snip_all . $cl_snip_phase, $category, $value_to_remove);
                        $success++;
                    }
                }
            }
            generate_rvt_orders('reporter');
            generate_rvt_orders('validator');
            generate_rvt_orders('transformer');
        } else {
            $success = 0;
        }
    } elsif (PHASE_GRAMMAR_SIMP eq $phase or
             PHASE_GRAMMAR_DEST eq $phase   ) {
        my $none_found = 1;
        while ($none_found) {
            my $rule_name = GenTest::Simplifier::Grammar_advanced::next_rule_to_process(
                                RULE_JOBS_GENERATED, RULE_WEIGHT);
            if (not defined $rule_name) {
                say("DEBUG: next_rule_to_process delivered undef.")
                    if Auxiliary::script_debug("S5");
                last;
            }
            if (PHASE_GRAMMAR_DEST eq $phase) {
                # Generate the destructive step.
                add_order($cl_snip_all . $cl_snip_phase, $rule_name, "_to_empty_string_only");
                $success++;
            }
            my @rule_unique_component_list =
                    GenTest::Simplifier::Grammar_advanced::get_unique_component_list($rule_name);
            say("DEBUG: unique components of rule '$rule_name' " .
                join("  ", @rule_unique_component_list)) if Auxiliary::script_debug("S5");
            if (1 < scalar @rule_unique_component_list) {
                foreach my $component (@rule_unique_component_list) {
                    add_order($cl_snip_all . $cl_snip_phase, $rule_name, $component);
                    $success++;
                }
                say("DEBUG: Rule '$rule_name' was decomposed into $success orders.")
                    if Auxiliary::script_debug("S5");
                # We decompose one rule only.
                $none_found = 0;
            } else {
                say("DEBUG: Rule '$rule_name' has only " . (scalar @rule_unique_component_list) .
                    " components.") if Auxiliary::script_debug("S5");
            }
            GenTest::Simplifier::Grammar_advanced::set_rule_jobs_generated($rule_name);
        }
    } elsif (PHASE_SIMP_END eq $phase) {
    } else {
        Carp::cluck("INTERNAL ERROR: Handling for phase '$phase' is missing.");
        my $status = STATUS_INTERNAL_ERROR;
        Batch::emergency_exit($status);
    }
    if ($success) {
        if (Auxiliary::script_debug("S5")) {
            dump_orders();
            Batch::dump_try_hashes();
        }
        return 1;
    } else {
        say("DEBUG: All possible orders were already generated. Will return 0.")
            if Auxiliary::script_debug("S4");
        return 0;
    }
} # End of sub generate_orders


sub add_order {

    my ($order_property1, $order_property2, $order_property3) = @_;

    our $order_id_now;
    $order_id_now = 0 if not defined $order_id_now;

    $order_id_now++;

    $order_array[$order_id_now][ORDER_EFFORTS_INVESTED]  = 0;
    $order_array[$order_id_now][ORDER_EFFORTS_LEFT_OVER] = $trials;
    $order_array[$order_id_now][ORDER_PROPERTY1]         = $order_property1;
    $order_array[$order_id_now][ORDER_PROPERTY2]         = $order_property2;
    $order_array[$order_id_now][ORDER_PROPERTY3]         = $order_property3;

    Batch::add_order($order_id_now);
    print_order($order_id_now) if Auxiliary::script_debug("S5");
}

sub register_result {
# Bookkeeping and adjust own behaviour to result and give the caller an order how to go on.
# lib/Batch.pm calling register_result provides
# use constant JOB_CL_SNIP    => 0;  # OMITTED
# use constant JOB_ORDER_ID   => 1;
# use constant JOB_MEMO1      => 2;  # undef or Child  grammar or Child  rvt_snip
#                                    # In history: $worker_array[$free_worker][WORKER_EXTRA1]
# use constant JOB_MEMO2      => 3;  # undef or Parent grammar or Parent rvt_snip
#                                    # In history: $worker_array[$free_worker][WORKER_EXTRA2]
# use constant JOB_MEMO3      => 4;  # undef or Adapted duration
#                                    # In history: $worker_array[$free_worker][WORKER_EXTRA3]
# Return Batch::REGISTER_.... (== An order how to proceed) or abort via Batch::emergency_exit.
#
    our $arrival_number;
    my ($order_id, $verdict, $saved_log_rel, $total_runtime,
        $grammar_used, $grammar_parent, $adapted_duration) = @_;

    if (@_ != 7) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: register_result : 7 Parameters (order_id, verdict, " .
                    "saved_log_rel, total_runtime, grammar_used, grammar_parent, " .
                    "adapted_duration) are required.");
        Batch::emergency_exit($status);
    }
    if (not defined $order_id or not defined $verdict) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: order_id is undef");
        Batch::emergency_exit($status);
    }
    Carp::cluck("DEBUG: Simplifier::register_result(order_id, verdict, saved_log_rel, " .
                "total_runtime, grammar_used, grammar_parent, adapted_duration)")
        if Auxiliary::script_debug("S4");

    my $return = 'INIT';

    $arrival_number = 1 if not defined $arrival_number;

    # 0. In case of a replay we need to pull information which is not part of the routine
    #    parameters but contained around end of the RQG run log.
    my $gentest_runtime;
    if ($verdict eq Verdict::RQG_VERDICT_REPLAY) {
        # 2019-01-11T18:44:45 [21041] INFO: GenTest: Effective duration in s : 193
        # 2018-11-19T16:16:19 [19309] SUMMARY: RQG GenData runtime in s : 0
        # 2018-11-19T16:16:19 [19309] SUMMARY: RQG GenTest runtime in s : 31
        # 2018-11-19T16:16:19 [19309] SUMMARY: RQG total runtime in s : 34
        ##### 2018-11-19T16:16:19 [19309] SUMMARY: RQG verdict : replay
        my $logfile = $workdir . "/" . $saved_log_rel;
        $gentest_runtime = Batch::get_string_after_pattern($logfile,
                               "INFO: GenTest: Effective duration in s : ");
        if (not defined $gentest_runtime) {
            $gentest_runtime = Batch::get_string_after_pattern($logfile,
                                   "SUMMARY: RQG GenTest runtime in s : ");
        }
        replay_runtime_fifo_update($gentest_runtime);
        say("DEBUG: Replayer with orderid : $order_id needed gentest_runtime : $gentest_runtime")
            if Auxiliary::script_debug("S5");
    }

    $grammar_used     = '<undef>' if not defined $grammar_used;
    $grammar_parent   = '<undef>' if not defined $grammar_parent;
    $adapted_duration = '<undef>' if not defined $adapted_duration;

    # 1. Bookkeeping
    my $iso_ts = isoTimestamp();
    my $line   = "$iso_ts | " .
        Auxiliary::lfill($arrival_number, Batch::RQG_NO_LENGTH)        . " | " .
        Auxiliary::rfill($verdict,        Verdict::RQG_VERDICT_LENGTH) . " | " .
        Auxiliary::lfill($saved_log_rel,  Batch::RQG_LOG_LENGTH)       . " | " .
        Auxiliary::lfill($order_id,       Batch::RQG_ORDERID_LENGTH)   . " | " .
        Auxiliary::lfill($total_runtime,  Batch::RQG_ORDERID_LENGTH)   . " | " .
        Auxiliary::rfill($grammar_used,   RQG_SPECIALITY_LENGTH)       . " | " .
        Auxiliary::rfill($grammar_parent, RQG_SPECIALITY_LENGTH)       . "\n";
    Batch::append_string_to_file ($result_file, $line);
    $arrival_number++;

    # 2. Update $left_over_trials, ORDER_EFFORTS_INVESTED, ORDER_EFFORTS_LEFT_OVER
    if      ($verdict eq Verdict::RQG_VERDICT_IGNORE           or
             $verdict eq Verdict::RQG_VERDICT_IGNORE_STATUS_OK or
             $verdict eq Verdict::RQG_VERDICT_IGNORE_BLACKLIST or
             $verdict eq Verdict::RQG_VERDICT_INTEREST         or
             $verdict eq Verdict::RQG_VERDICT_REPLAY           or
             $verdict eq Verdict::RQG_VERDICT_INIT       ) {
        $order_array[$order_id][ORDER_EFFORTS_INVESTED]++;
        $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]--;
        $left_over_trials--;
    } elsif ($verdict eq Verdict::RQG_VERDICT_IGNORE_STOPPED) {
        # Do nothing with the $order_array[$order_id][ORDER_EFFORTS_*].
    } else {
        say("INTERNAL ERROR: Final Verdict '$verdict' is not treated/unknown. " .
            "Will ask for an emergency_exit.");
        my $status = STATUS_INTERNAL_ERROR;
        Batch::emergency_exit($status);
    }
    say("DEBUG: Simplifier::register_result : left_over_trials : $left_over_trials")
        if Auxiliary::script_debug("S4");

    my $target = $workdir . "/" . $best_grammar;
    my $efforts_invested = $order_array[$order_id][ORDER_EFFORTS_INVESTED];

    # 3. React on the verdict and decide about the nearby future of the order.
    if      ($verdict eq Verdict::RQG_VERDICT_IGNORE_STOPPED) {
        # We need to make some additional run with this order as soon as possible.
        Batch::add_to_try_first($order_id);
        return Batch::REGISTER_GO_ON;
    } elsif ($verdict eq Verdict::RQG_VERDICT_REPLAY) {
        $campaign_success++;
        if (PHASE_FIRST_REPLAY   eq $phase or
            PHASE_THREAD1_REPLAY eq $phase or
            PHASE_FINAL_REPLAY   eq $phase   ) {
            # The fate of the phase is decided.
            $phase_switch = 1;
            Batch::stop_workers(Batch::STOP_REASON_WORK_FLOW);
            # In the current phase we have used all time the same grammar and that is the
            # current $child_grammar.
            my $source = $workdir . "/" . $child_grammar;
            Batch::copy_file($source, $target);
            if (PHASE_THREAD1_REPLAY eq $phase) {
                Batch::stop_workers(Batch::STOP_REASON_WORK_FLOW);
                say("INFO: We had a replay in phase '$phase'. " .
                    "Will adjust the parent grammar and the number of threads used to 1.");
                $threads = 1;
                $cl_snip_all .= " --threads=1";
                reload_grammar($child_grammar);
            } elsif (PHASE_FINAL_REPLAY eq $phase) {
            }
            Batch::add_to_try_never($order_id);
            return Batch::REGISTER_SOME_STOPPED;
        } elsif (PHASE_RVT_SIMP eq $phase) {
            my $rvt_now = get_shrinked_rvt_options(undef, undef, 0);
            if ($grammar_parent eq $rvt_now) {
                # Its a first replayer based on the current parent rvt options.
                # add_to_try_never stops all running RQG Worker using that order_id.
                Batch::stop_worker_young;
                Batch::stop_worker_on_order($order_id);
                Batch::add_to_try_never($order_id);
                my $rvt_options = get_shrinked_rvt_options($order_array[$order_id][ORDER_PROPERTY2],
                                         $order_array[$order_id][ORDER_PROPERTY3], 1);
                if (not defined $rvt_options) {
                    Carp::cluck("INTERNAL ERROR: rvt_options is undef.");
                    my $status = STATUS_INTERNAL_ERROR;
                    Batch::emergency_exit($status);
                }
              # return Batch::REGISTER_SOME_STOPPED;
                return Batch::REGISTER_GO_ON;
            } else {
                # Its a too late replayer.
                # But the order was quite good. So try it again.
                $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]++;
                $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]++;
                Batch::add_to_try_intensive_again($order_id);
                return Batch::REGISTER_GO_ON;
            }
        } elsif (PHASE_GRAMMAR_SIMP eq $phase or
                 PHASE_GRAMMAR_DEST eq $phase   ) {
            if ($grammar_parent eq $parent_grammar) {
                # Its a first replayer based on the current parent grammar.
                reload_grammar($grammar_used);
                # add_to_try_never stops all running RQG Worker using that order_id.
                Batch::stop_worker_young;
                Batch::stop_worker_on_order($order_id);
                Batch::add_to_try_never($order_id);
              # return Batch::REGISTER_SOME_STOPPED;
                return Batch::REGISTER_GO_ON;
            } else {
                # Its a too late replayer.
                # But the order was quite good. So try it again.
                $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]++;
                $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]++;
                Batch::add_to_try_intensive_again($order_id);
                return Batch::REGISTER_GO_ON;
            }
        } else {
            my $status = STATUS_INTERNAL_ERROR;
            Carp::cluck("INTERNAL ERROR: The phase '$phase' is unknown. " .
                "Will exit with status " . status2text($status) . "($status)");
            Batch::emergency_exit($status);
        }
      # The handling of replayers ends here ----------------------------------
    } elsif ($verdict eq Verdict::RQG_VERDICT_IGNORE            or
             $verdict eq Verdict::RQG_VERDICT_IGNORE_STATUS_OK  or
             $verdict eq Verdict::RQG_VERDICT_IGNORE_BLACKLIST  or
             $verdict eq Verdict::RQG_VERDICT_INTEREST          or
             $verdict eq Verdict::RQG_VERDICT_INIT                ) {
        if (0 >= $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER]) {
            # We have already too much invested. Stop using that order.
            say("DEBUG: order_id($order_id), trials($trials), efforts_invested($efforts_invested), " .
                "efforts_left_over(" . $order_array[$order_id][ORDER_EFFORTS_LEFT_OVER] .
                ") --> Stop using that order.") if Auxiliary::script_debug("S4");
            # add_to_try_exhausted stops all running RQG Worker using that order_id.
            Batch::add_to_try_exhausted($order_id);
            Batch::stop_worker_on_order($order_id);
            return Batch::REGISTER_GO_ON;
        } else {
            if ($verdict eq Verdict::RQG_VERDICT_IGNORE_BLACKLIST) {
                Batch::add_to_try_over_bl($order_id);
                return Batch::REGISTER_GO_ON;
            } else {
                Batch::add_to_try_over($order_id);
                return Batch::REGISTER_GO_ON;
            }
        }
    } else {
        say("INTERNAL ERROR: Final Verdict '$verdict' is not treated/unknown. " .
            "Will ask for an emergency_exit.");
        my $status = STATUS_INTERNAL_ERROR;
        Batch::emergency_exit($status);
    }

    Batch::dump_try_hashes if Auxiliary::script_debug("S6");
    # Check consistency of the hash.
    # Batch::check_try_hashes();

    my $hint_given;
    if ($left_over_trials) {
        $hint_given = 0;
        if((PHASE_GRAMMAR_SIMP eq $phase or PHASE_GRAMMAR_DEST eq $phase) and
           3 <= Batch::get_out_of_ideas() and
           0 == Batch::known_orders_waiting ) {
           say("DEBUG: The current campaign has reached the end after $campaign_success replays.");
           Batch::dump_try_hashes if Auxiliary::script_debug("S4");
           $phase_switch = 1;
        }
        return $return;
    } else {
        if (PHASE_FIRST_REPLAY eq $phase) {
            say("SUMMARY: No replay with the initial grammar.");
            say("HINT: Maybe the\n" .
                "HINT: - black/white lists (especially the pattern sections) are faulty or " .
                "HINT: - RQG test setup (basedir, grammar etc.) is wrong or "                .
                "HINT: - trials/duration are too small.");
            say("Giving up.");
            return (Batch::REGISTER_END);
        } elsif (PHASE_THREAD1_REPLAY eq $phase) {
            if (not $hint_given) {
                say("No replay with threads=1."                                                    .
                    "HINT: So it seems to be a concurrency problem like connection/thread m "      .
                    "activity clashes with\n"                                                      .
                    "HINT: - connection/thread n activity or\n"                                    .
                    "HINT: - execution of an EVENT        or\n"                                    .
                    "HINT: - asynchronous activity of replication thread, InnoDB Purge or "        .
                    "similar.\n") ;
            }
            $phase_switch = 1;
            return $return;
            # return (Batch::REGISTER_SOME_STOPPED);
        } elsif (PHASE_FINAL_REPLAY eq $phase) {
            say("Replaying the desired outcome with the final YY grammar and RQG setup failed.");
            return (Batch::REGISTER_END);
        } else {
            return (Batch::REGISTER_END);
        }
    }

} # End sub register_result


sub switch_phase {

    say("DEBUG: Simplifier::switch_phase: Enter routine. Current phase is '$phase'.")
        if Auxiliary::script_debug("S4");

    my $iso_ts = isoTimestamp();

    my $rvt_snip = get_shrinked_rvt_options(undef, undef, 0);
    # ATTENTION:
    # $rvt_snip with that value needs to be added to any phase EXCEPT PHASE_RVT_SIMP.
    if (not defined $rvt_snip) {
        Carp::cluck("INTERNAL ERROR: The rvt_snip computed is undef. " .
            "Will ask for an emergency_exit.");
        my $status = STATUS_INTERNAL_ERROR;
        Batch::emergency_exit($status);
    }

    # Treat phases consisting of maybe repeated campaigns first
    # == The cases where we maybe stay in the current phase and do not shift.
    if ((PHASE_GRAMMAR_SIMP eq $phase or PHASE_GRAMMAR_DEST eq $phase) and
        ($campaign_success or 2 > $campaign_number)) {
        # We had either
        # - less than two grammar simplification campaigns at all (only one is frequent not enough)
        #   Background:
        #   We might have a high fraction of verdicts != replay because hitting other errors or
        #   STATUS_OK even though the grammar is capable to replay.
        # - success within the last grammar simplification campaign
        # and so we run one campaign more.
        $campaign_number++;
        $left_over_trials  = TRIALS_SIMP;
        $cl_snip_phase     = " $rvt_snip";
        Batch::write_result("$iso_ts ---------- $phase campaign $campaign_number ----------\n" .
                            $iso_ts . $title_line_part);
        # Q1: How looks $grammar_string like? Last parent grammar?
        # Q2:

        load_grammar($parent_grammar, 10);
        Batch::init_order_management();
        say("DEBUG: Simplifier::switch_phase: Leaving routine. Current phase is '$phase'.")
                if Auxiliary::script_debug("S4");
        $campaign_success  = 0;
        $refill_number     = 0;
#       $out_of_ideas      = 0;
        $phase_switch      = 0;
        # Essential: We are already in PHASE_GRAMMAR_SIMP/PHASE_GRAMMAR_DEST and will stay there
        #            for another campaign.
        return;
    }
    if ((PHASE_RVT_SIMP eq $phase) and ($campaign_success)) {
        # We had success within the last grammar simplification campaign and so run one more.
        # No use of $campaign_number == 1 as criterion for repetition.
        $campaign_number++;
        $have_rvt_generated = 0;
        my $target          = $workdir . "/" . $child_grammar;
        $left_over_trials   = TRIALS_SIMP;
        $cl_snip_phase      = " --grammar=" . $target ;
        Batch::write_result("$iso_ts ---------- $phase campaign $campaign_number ---------- ($child_grammar)\n" .
                            $iso_ts . $title_line_part);
        Batch::init_order_management();
        say("DEBUG: Simplifier::switch_phase: Leaving routine. Current phase is '$phase'.")
                if Auxiliary::script_debug("S4");
        $campaign_success   = 0;
#       $out_of_ideas       = 0;
        $phase_switch       = 0;
        return;
    }

    $phase = shift @simp_chain;

    # Omit phases which make no sense.
    if (PHASE_THREAD1_REPLAY eq $phase and 1 == $threads ) {
        say("INFO: threads is alreay 1. Omitting phase '" . PHASE_THREAD1_REPLAY . "'.");
        $phase = shift @simp_chain;
    }

    if      (PHASE_FIRST_REPLAY eq $phase)     {
        $left_over_trials   = $trials;
        make_child_from_parent();
        my $target          = $workdir . "/" . $child_grammar;
        $cl_snip_phase      = " $rvt_snip --grammar=" . $target;
        Batch::write_result("$iso_ts ---------- $phase ---------- ($child_grammar)\n" .
                            $iso_ts . $title_line_part);
    } elsif (PHASE_RVT_SIMP eq $phase)   {
        $have_rvt_generated = 0;
        $campaign_number    = 1;
        $left_over_trials   = TRIALS_SIMP;
        make_child_from_parent();
        # $rvt_snip = "";
        my $target = $workdir . "/" . $child_grammar;
        # $cl_snip_phase      = " $rvt_snip --grammar=" . $target ;
        $cl_snip_phase      = " --grammar=" . $target ;
        Batch::write_result("$iso_ts ---------- $phase campaign $campaign_number ---------- ($child_grammar)\n" .
                            $iso_ts . $title_line_part);
    } elsif (PHASE_THREAD1_REPLAY eq $phase)   {
        $left_over_trials   = $trials;
        make_child_from_parent();
        my $target          = $workdir . "/" . $child_grammar;
        $cl_snip_phase      = " $rvt_snip --grammar=" . $target . " --threads=1";
        Batch::write_result("$iso_ts ---------- $phase ---------- ($child_grammar)\n" .
                            $iso_ts . $title_line_part);
    } elsif (PHASE_GRAMMAR_SIMP eq $phase or
             PHASE_GRAMMAR_DEST eq $phase   ) {
        $campaign_number    = 1;
        $left_over_trials   = TRIALS_SIMP;
        $cl_snip_phase      = " $rvt_snip";
        load_grammar($parent_grammar, 10);
        Batch::write_result("$iso_ts ---------- $phase campaign $campaign_number ----------\n" .
                            $iso_ts . $title_line_part);
    } elsif (PHASE_FINAL_REPLAY eq $phase)   {
        $left_over_trials   = $trials;
        make_child_from_parent();
        my $target          = $workdir . "/" . $child_grammar;
        $cl_snip_phase      = " $rvt_snip --grammar=" . $target;
        Batch::write_result("$iso_ts ---------- $phase ---------- ($child_grammar)\n" .
                            $iso_ts . $title_line_part);
    } elsif (PHASE_SIMP_END eq $phase)   {
        $grammar_string = GenTest::Simplifier::Grammar_advanced::init(
                              $workdir . "/" . $parent_grammar, $threads, 200, $grammar_flags);
        Batch::make_file($workdir . "/final.yy", $grammar_string . "\n");
        say("");
        say("");
        say("SUMMARY: Maybe simplified number of threads : $threads");
        say("SUMMARY: Maybe simplified RVT setting :       '" . $rvt_snip . "'");
        say("SUMMARY: Maybe Simplified best tested RQG Grammar : '" . $workdir . "/$best_grammar'");
        say("");
        say("");
    } else {
        Carp::cluck("INTERNAL ERROR: Handling for phase '$phase' is missing.");
        my $status = STATUS_INTERNAL_ERROR;
        Batch::emergency_exit($status);
    }
    Batch::init_order_management();
    say("DEBUG: Simplifier::switch_phase: Leaving routine. Current phase is '$phase'.")
        if Auxiliary::script_debug("S4");
    $campaign_success = 0;
#   $out_of_ideas     = 0;

    $phase_switch     = 0;

} # End of sub switch_phase


my @replay_runtime_fifo;
# - The value for duration finally assigned to some RQG run will be all time <= $duration.
# - In case the assigned duration is finally the deciding delimiter than it is expected that
#   the measured gentest runtime is slightly bigger than that assigned duration.
sub replay_runtime_fifo_init {
    my ($elements) = @_;
    # In order to have simple code and a smooth queue of computed values we precharge with the
    # duration (assigned/calculated during init).
    for my $num (0..($elements - 1)) {
        $replay_runtime_fifo[$num] = $duration;
    }
}

sub replay_runtime_fifo_update {
    my ($value) = @_;

    shift @replay_runtime_fifo;
    if ($value <= $duration) {
        push @replay_runtime_fifo, $value;
    } else {
        push @replay_runtime_fifo, $duration;
    }
    replay_runtime_fifo_print();
}

sub replay_runtime_fifo_print {
    my $adapted_duration = replay_runtime_adapt();
    say("DEBUG: Adapted duration : $adapted_duration , replay_runtime_fifo : " .
        join(" ", @replay_runtime_fifo)) if Auxiliary::script_debug("S5");
}

sub replay_runtime_adapt {
# Purpose
# -------
# Provide some optimized value for duration.
# The value computed depends on
# - $duration (== value assigned in rqg_batch call and/or config file)
# - $phase
# - $duration_adaption
# - values collected within replay_runtime_fifo during runtime
#
    my $value;

    if      (PHASE_FIRST_REPLAY   eq $phase or
             PHASE_THREAD1_REPLAY eq $phase or
             PHASE_RVT_SIMP       eq $phase or
             PHASE_FINAL_REPLAY   eq $phase   ) {
        return $duration;
    } elsif (PHASE_GRAMMAR_SIMP   eq $phase or
             PHASE_GRAMMAR_DEST   eq $phase   ) {
        if      (DURATION_ADAPTION_NONE eq $duration_adaption) {
            $value = $duration;
        } elsif (DURATION_ADAPTION_MAX_MID eq $duration_adaption) {
            my @desc_fifo = sort { $b <=> $a } @replay_runtime_fifo;
            $value = shift @desc_fifo;
            $value = int(($value + $duration) / 2);
        } elsif (DURATION_ADAPTION_MAX eq $duration_adaption) {
            my @desc_fifo = sort { $b <=> $a } @replay_runtime_fifo;
            $value = shift @desc_fifo;
        } elsif (DURATION_ADAPTION_EXP eq $duration_adaption) {
            # Lets assume the following:
            # The per config assigned duration is 300s.
            # The next derivate of the current parent grammar is either
            # A) capable to replay at all (*): 1 - z
            #    (*) Implies infinite number of attempts and endless runtime.
            # or
            # B) not capable to replay (**):       z
            #    (**) And that applies no matter how often we try.
            # 0 <= z <= 1
            # Some more detail to A)
            # The likelihood that we replay with endless duration and attempts is 1 - x.
            # Caused by the fact that the duration used is far way lower including that we have some
            # limited number of attempts we should expect for that
            #     0 <= 1 - y (== What we experience in average) <= 1 - z
            # What we would like to have
            #    Make based on (1 - y) some estimation (1 - x) which is roughly a bit bigger than
            #    (1 - z)
            # runtime properties like an actual average replaying grammar.
            # Ideal would be some calculation leading to some value for adapted duration which
            # would guarantee that >= 95% of all replays are included.
            # Note about the formulas used here
            # ---------------------------------
            # I do NOT claim that the YY grammar processing timespans of attempts which replayed
            # collected in @replay_runtime_fifo must follow some normal distribution!
            # Rationale:
            # Even the runtime X of some absolute deterministic test like easy doable based on MTR
            # varies depending on concurrent load of the testing box.
            # - concurrent test Y could differ from X per code
            # - even if the code of Y and X is the same Y could be started at a different point of
            #   time and be therefore in some different phase like initialize the server or compare
            #   results
            # In case of the Simplifier we have
            # - 1 up till n concurrent RQG runs
            # - these RQG runs have usually differing grammars including differing start times
            #   like run m is in phase YY grammar processing and some arbitrary run r is within
            #   the phase gendata.
            # The math used should be nothing else than a helper for computing some maximum
            # duration. In case that maximum duration is exceeded than it is assumed that either
            # - the grammar is not capable to replay at all
            # - the grammar is capable to replay but we have during the run already reached a state
            #   where a replay has become impossible
            #   Example:
            #   Assert during DROP TABLE and the CREATE TABLE was already shrinked away.
            #   In case the first DROP had luck and did not hit the assert than the game is over.
            # In both cases limiting the duration would give a speedup.
            # Of course the computed maximum duration could be more or less imperfect.
            # My hope is the following:
            # - As long as the wins by good predictions overcompensate the losses by bad
            #   predictions we have some benefit.
            # - DURATION_ADAPTION_EXP shows compared to DURATION_ADAPTION_MAX
            #   - a more smooth adaptation with less drastic jumps
            #   - some more aggressive adaptation --> in average better speedup but without
            my $num_samples = scalar @replay_runtime_fifo;

            my $single_sum  = 0;
            foreach my $val (@replay_runtime_fifo) {
                $single_sum  += $val;
            }
            my $mean = $single_sum / $num_samples;
            my $quadrat_dev_sum = 0;
            foreach my $val (@replay_runtime_fifo) {
                my $single_dev = $val - $mean;
                $quadrat_dev_sum += $single_dev * $single_dev;
            }
            my $std_dev = sqrt($quadrat_dev_sum / ($num_samples - 1));
            # >= 95% of all values should occur within 0 till $mean + $value_e.
            my $confidence = $std_dev * 2.26 / sqrt($num_samples);
            my $value_e = int($mean + $confidence);
            if ($value_e > $duration) {
                $value = $duration;
            } else {
                $value = $value_e;
            }
            say("DEBUG: num_samples($num_samples), mean($mean), confidence($confidence), " .
                "value_e($value_e), value($value)") if Auxiliary::script_debug("S4");
        } else {
            my $status = STATUS_INTERNAL_ERROR;
            Carp::cluck("INTERNAL ERROR: replay_runtime_adapt : The duration_adaption " .
                "'$duration_adaption' is unknown. Will exit with status " .
                status2text($status) . "($status)");
            Batch::emergency_exit($status);
        }
        return $value;
    } else {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: replay_runtime_adapt : The phase '$phase' is unknown. " .
            "Will exit with status " . status2text($status) . "($status)");
        Batch::emergency_exit($status);
    }
} # End sub replay_runtime_adapt


sub report_replay {
# Purpose
# -------
# Try to make progress (have a better parent grammar as base) as soon as possible.
# This applies to the phases PHASE_GRAMMAR_SIMP and PHASE_RVT_SIMP only.
#

    my ($replay_grammar, $replay_grammar_parent, $order_id) = @_;

    if (@_ != 3) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: report_replay : 3 Parameters (replay_grammar, " .
                    "replay_grammar_parent, order_id) are required.");
        Batch::emergency_exit($status);
    }
    # FIXME:
    # Activate the code below in case FIRST_REPLAY is adjusted to it
#   if (not defined $replay_grammar or not defined $replay_grammar_parent or
#       not defined $order_id                                               ) {
#       Carp::cluck("INTERNAL ERROR: All values must be defined.");
#       my $status = STATUS_INTERNAL_ERROR;
#       Batch::emergency_exit($status);
#   }

    my $response = Batch::REGISTER_GO_ON;

    if (PHASE_GRAMMAR_SIMP eq $phase or
        PHASE_GRAMMAR_DEST eq $phase   ) {
        if ($parent_grammar eq $replay_grammar_parent) {
            # The grammar used is a child of the current parent grammar and that means
            # its a first winner (!= a winner with outdated grammar).
            my $source = $workdir . "/" . $replay_grammar;
            my $target = $workdir . "/" . $best_grammar;
            Batch::copy_file($source, $target);
            # This means the child grammar used should become the base of the next parent grammar.
            reload_grammar($replay_grammar);
            Batch::stop_worker_young;
            Batch::stop_worker_on_order_except_replayer($order_id);
            Batch::add_to_try_never($order_id);
        } else {
            # Its a replayer with outdated grammar.
            # Hence we can postpone decision+loading to the point of time when the main process
            # of the RQG worker was reaped and the result gets processed.
            # So we do nothing.
        }
    } elsif (PHASE_RVT_SIMP eq $phase) {
        my $rvt_now = get_shrinked_rvt_options(undef, undef, 0);
        if ($replay_grammar_parent eq $rvt_now) {
            # Its a first winner.
            my $rvt_options = get_shrinked_rvt_options($order_array[$order_id][ORDER_PROPERTY2],
                                     $order_array[$order_id][ORDER_PROPERTY3], 1);
            if (not defined $rvt_options) {
                Carp::cluck("INTERNAL ERROR: rvt_options is undef.");
                my $status = STATUS_INTERNAL_ERROR;
                Batch::emergency_exit($status);
            }
            Batch::stop_worker_young;
            Batch::stop_worker_on_order_except_replayer($order_id);
            Batch::add_to_try_never($order_id);
        } else {
            # Its a too late winner.
            # So we do nothing.
        }
    } else {
        Batch::stop_worker_young;
        Batch::stop_worker_on_order_except_replayer($order_id);
        Batch::add_to_try_never($order_id);
    }
    return $response;
} # End sub report_replay

sub load_grammar {

# In case loading the grammar fails -> $grammar_string is undef
# -> load_step will detect that and abort.

    my ($grammar_file, $max_inline_length) = @_;

    # Actions of GenTest::Simplifier::Grammar_advanced::init
    # ...  Gentest::...Simplifier ....load_grammar($grammar_file);
    # ...  fill_rule_hash();
    # ...  print_rule_hash();
    # ...  analyze_all_rules(); -- Maintains counter except weight and removes unused rules
    # ...  compact_grammar      -- collapseComponents (unique) and inlining
    # Attention: This resets if some rule was already processed.
    $grammar_string = GenTest::Simplifier::Grammar_advanced::init(
             $workdir . "/" . $grammar_file, $threads, $max_inline_length, $grammar_flags);
    load_step();
    my $iso_ts = isoTimestamp();
    Batch::write_result("$iso_ts          $grammar_file     loaded with threads = $threads " .
                        "==> new parent grammar '$parent_grammar'\n");
}

sub reload_grammar {

# In case reloading the grammar fails -> $grammar_string is undef
# -> load_step will detect that and abort.

    my ($grammar_file) = @_;

    # Actions of GenTest::Simplifier::Grammar_advanced::reload_grammar
    # ...  Gentest::...Simplifier ....load_grammar($grammar_file);
    # ...  reset_rule_hash_values();  <-- This preserves the info that jobs for a rule were generated!
    # ...  print_rule_hash();
    # ...  analyze_all_rules(); -- Maintains counter except weight and removes unused rules
    # ...  compact_grammar();   -- collapseComponents (unique) and NO inlining
    # Problem: This seems to reset if some rule was already processed.
    $grammar_string = GenTest::Simplifier::Grammar_advanced::reload_grammar(
                      $workdir . "/" . $grammar_file, $threads, $grammar_flags);
    load_step();
    my $iso_ts = isoTimestamp();
    Batch::write_result("$iso_ts          $grammar_file     loaded with threads = $threads " .
                        "==> new parent grammar '$parent_grammar'\n");
}

sub load_step {

    if (not defined $grammar_string) {
        my $status = STATUS_INTERNAL_ERROR;
        say("INTERNAL ERROR: Loading a grammar file within Simplifier::Grammar_advanced failed. " .
            "Will ask for emergency exit." .
        Auxiliary::exit_status_text($status));
        Batch::emergency_exit($status);
    }
    my $status = GenTest::Simplifier::Grammar_advanced::calculate_weights();
    if($status) {
        my $status = STATUS_INTERNAL_ERROR;
        say("INTERNAL ERROR: GenTest::Simplifier::Grammar_advanced::calculate_weights failed. " .
            "Will ask for emergency exit." .
        Auxiliary::exit_status_text($status));
        Batch::emergency_exit($status);
    }
    # Aborts if
    # - $grammar_string is not defined
    # - creation of parent grammar file fails
    make_parent_from_string ($grammar_string);
}


sub get_shrinked_rvt_options {
    my ($option_to_attack, $value_to_remove, $write_through) = @_;

    if (@_ != 3) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: get_shrinked_rvt_options : 3 Parameters (option_to_attack," .
                    "value_to_remove, $write_through) are required.");
        Batch::emergency_exit($status);
    }
    if (not defined $option_to_attack      or
        $option_to_attack eq 'reporter'    or
        $option_to_attack eq 'validator'   or
        $option_to_attack eq 'transformer'   ) {
        # Do nothing.
    } else {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: get_shrinked_rvt_options : option_to_attack is '" .
                    "$option_to_attack'  but needs to be undef or 'reporter' or 'validator' or " .
                    "'transformer',");
        Batch::emergency_exit($status);
    }
    if (not defined $write_through) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: get_shrinked_rvt_options : write_through is undef.");
        Batch::emergency_exit($status);
    }

    my %reporter_hash_copy    = %reporter_hash;
    my %validator_hash_copy   = %validator_hash;
    my %transformer_hash_copy = %transformer_hash;

    if (defined $option_to_attack) {
        my $shrinked = 0;
        if      ($option_to_attack eq 'reporter') {
            if ("_all_to_None" eq $value_to_remove) {
                if ((1 != scalar keys %reporter_hash_copy)    or
                    (1 == scalar keys %reporter_hash_copy and
                     not exists $reporter_hash_copy{'None'})    ) {
                    # We have either
                    # - more elements than just one (-> in minimum one cannot be 'None')
                    # - one element and that is not 'None'
                    %reporter_hash_copy = ();
                    $reporter_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } elsif ("_add_None" eq $value_to_remove) {
                if (not exists $reporter_hash_copy{'None'}) {
                    $reporter_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } else {
                # Other value --> We try a removal
                if (exists $reporter_hash_copy{$value_to_remove}) {
                    delete $reporter_hash_copy{$value_to_remove};
                    say("DEBUG: get_shrinked_rvt_options : reporter - $value_to_remove")
                        if Auxiliary::script_debug("S6");
                    $shrinked = 1;
                } else {
                    say("DEBUG: get_shrinked_rvt_options : reporter already without " .
                        "$value_to_remove") if Auxiliary::script_debug("S6");
                    $shrinked = 0;
                }
            }
        } elsif ($option_to_attack eq 'validator') {

            if ("_all_to_None" eq $value_to_remove) {
                if ((1 != scalar keys %validator_hash_copy)    or
                    (1 == scalar keys %validator_hash_copy and
                     not exists $validator_hash_copy{'None'})    ) {
                    # We have either
                    # - more elements than just one (-> in minimum one cannot be 'None')
                    # - one element and that is not 'None'
                    %validator_hash_copy = ();
                    $validator_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } elsif ("_add_None" eq $value_to_remove) {
                if (not exists $validator_hash_copy{'None'}) {
                    $validator_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } else {
                # Other value --> We try a removal
                if (exists $validator_hash_copy{$value_to_remove}) {
                    delete $validator_hash_copy{$value_to_remove};
                    say("DEBUG: get_shrinked_rvt_options : validator - $value_to_remove")
                        if Auxiliary::script_debug("S6");
                    $shrinked = 1;
                } else {
                    say("DEBUG: get_shrinked_rvt_options : validator already without " .
                        "$value_to_remove") if Auxiliary::script_debug("S6");
                    $shrinked = 0;
                }
            }

        } elsif ($option_to_attack eq 'transformer') {
            if ("_all_to_None" eq $value_to_remove) {
                if ((1 != scalar keys %transformer_hash_copy)    or
                    (1 == scalar keys %transformer_hash_copy and
                     not exists $transformer_hash_copy{'None'})    ) {
                    # We have either
                    # - more elements than just one (-> in minimum one cannot be 'None')
                    # - one element and that is not 'None'
                    %transformer_hash_copy = ();
                    $transformer_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } elsif ("_add_None" eq $value_to_remove) {
                if (not exists $transformer_hash_copy{'None'}) {
                    $transformer_hash_copy{'None'} = 1;
                    $shrinked = 1;
                } else {
                    $shrinked = 0;
                }
            } else {
                # Other value --> We try a removal
                if (exists $transformer_hash_copy{$value_to_remove}) {
                    delete $transformer_hash_copy{$value_to_remove};
                    say("DEBUG: get_shrinked_rvt_options : transformer - $value_to_remove")
                        if Auxiliary::script_debug("S6");
                    $shrinked = 1;
                } else {
                    say("DEBUG: get_shrinked_rvt_options : transformer already without " .
                        "$value_to_remove") if Auxiliary::script_debug("S6");
                    $shrinked = 0;
                }
            }

        }
        if (not $shrinked) {
            say("DEBUG: get_shrinked_rvt_options : The combination option_to_attack " .
                "'$option_to_attack' value_to_remove '$value_to_remove' has become invalid.")
                if Auxiliary::script_debug("S5");
            return undef;
        }
    }

    my $rvt_option_snip = '';
    if (scalar keys %reporter_hash_copy)    {
        $rvt_option_snip .= " --reporters="    . join(",", sort keys %reporter_hash_copy);
    }
    if (scalar keys %validator_hash_copy)   {
        $rvt_option_snip .= " --validators="   . join(",", sort keys %validator_hash_copy);
    }
    if (scalar keys %transformer_hash_copy) {
        $rvt_option_snip .= " --transformers=" . join(",", sort keys %transformer_hash_copy);
    }
    if (defined $rvt_option_snip and 1 == $write_through) {
        %reporter_hash    = %reporter_hash_copy;
        %validator_hash   = %validator_hash_copy;
        %transformer_hash = %transformer_hash_copy;
        say("INFO: Reporter/validator/transformer setting rewrite to ->$rvt_option_snip<-.");
        my $iso_ts = isoTimestamp();
        Batch::write_result("$iso_ts          Reporter/validator/transformer shrinked " .
                        "==> new setting '" . $rvt_option_snip . "'.\n");
    }

    return $rvt_option_snip;
}

sub make_parent_from_string {

    my ($grammar_string) = @_;

    if (not defined $grammar_string) {
        my $status = STATUS_INTERNAL_ERROR;
        Carp::cluck("INTERNAL ERROR: grammar_string is not defined.");
        Batch::emergency_exit($status);
    }
    $parent_grammar= "p" . Auxiliary::lfill0($parent_number,5) . ".yy";
    Batch::make_file($workdir . "/" . $parent_grammar, $grammar_string . "\n");
    $parent_number++;
}

sub make_child_from_parent {
    $child_grammar = "c" . Auxiliary::lfill0($child_number,5) . ".yy";
    my $source     = $workdir . "/" . $parent_grammar;
    my $target     = $workdir . "/" . $child_grammar;
    Batch::copy_file($source, $target);
    $child_number++;
}

1;

