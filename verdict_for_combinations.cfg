{

'whitelist_statuses' => [
    'STATUS_ANY_ERROR',
],

'whitelist_patterns' => [
    # We have no special focus.
],

'blacklist_statuses' => [
    'STATUS_OK',
],

'blacklist_patterns' => [
    # [ <search_pattern> , <description like MDEV-nnnn> ]
    # ---------------------------------------------------
    # RQG runs showing this pattern end frequent with the status
    # STATUS_ENVIRONMENT_FAILURE(110). In case its a grammar maintained by hand than the
    # grammar is faulty and should be corrected.
    # But grammar simplification and also grammar masking run some automatic mangling of
    # grammars which could lead to the same effect because of non avoidable and harmless
    # reason. So we throw the remainings of such runs away and save by that resources.
    [ 'bad_grammar' , 'Possible endless loop in grammar.'                                         ],
    #
    # Grammars could have the unfortunate runtime property to cause some dramatic growth
    # of storage space consumption. This is especially valid in case of grammars generated
    # - during test simplification
    # - via grammar masking.
    # Example: All DROPs and DELETEs were shrinked away.
    #
    # The rqg_batch.pl ResourceControl will try to prevent negative consequences by stopping
    # selected RQG runs and freeing the resources. But in case the speed of the changes
    # exceeds the capabilities of ResourceControl or ResourceControl is disabled than
    # some typical outcome (observed before ResourceControl was implemented) is:
    # The DB server asserts, threads and/or periodic reporters exit with (hopefully)
    # STATUS_SERVER_CRASHED, the reporter Backtrace prints content of the server error log
    # and lets some debugger analyze the core file and than RQG exits with (again hopefully)
    # STATUS_SERVER_CRASHED.
    # Than in case of some "unsharp" setup of the whitelists (statuses == STATUS_ANY_ERROR,
    # patterns empty) that all gets valuated as replay.
    # But its either
    # - (most likely) a replay of some known "natural" effect which is not a defect
    # or
    # - (quite unlikely) the replay of a defect but the surviving data are not sufficient
    #   for analysis and we should better not waste time on that.
    # Conclusion:
    # Runs where we hit trouble with storage space are "unwanted".
    # Server error log pattern: ..... (Error 28 is OS: No space left on device)
    # [ERROR] InnoDB: preallocating 12582912 bytes for file ./test/#sql-1f36d_10.ibd failed with error 28
    # [ERROR] InnoDB: preallocating 65536 bytes for file ./test/FTS_0000000000000524_00000000000005f9_INDEX_5.ibd failed with error 28
    [ 'bad_environment_1' , '\[ERROR\] InnoDB: preallocating .{1,120} with error 28'              ],
    # Debugger output pattern:
    #    BFD: Warning: <core file> is truncated: expected core file size >= 959647744, found: 55398400.
    [ 'bad_environment_2' , '  is truncated: expected core file size '                            ],
    #
    # Open bugs
    [ 'MDEV-17844' , 'mysqld: .{1,150}rem0rec.cc:.{1,30} bool rec_offs_validate.{1,150}Assertion .ulint.rec. == offsets.2.. failed.' ],
    [ 'MDEV-19555' , 'mysqld: .{1,150}sql_error.h:.{1,30} uint Diagnostics_area::sql_errno\(\) const: Assertion .m_status == DA_ERROR. failed.' ],
    #
],

'search_var_size' => 30000000,

}



